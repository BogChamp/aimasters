\documentclass[12pt]{extreport}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}        % Кодировка входного документа;
                                    % при необходимости, вместо cp1251
                                    % можно указать cp866 (Alt-кодировка
                                    % DOS) или koi8-r.

\usepackage[english,russian]{babel} % Включение русификации, русских и
                                    % английских стилей и переносов
%%\usepackage{a4}
%%\usepackage{moreverb}
\usepackage{amsmath,amsfonts,amsthm,amssymb,amsbsy,amstext,amscd,amsxtra,multicol}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning}
\usepackage{multicol} %Несколько колонок
\usepackage{graphicx}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[stable]{footmisc}

\usepackage[linesnumbered]{algorithm2e}   

%% \voffset-5mm
%% \def\baselinestretch{1.44}
\renewcommand{\theequation}{\arabic{equation}}
\def\hm#1{#1\nobreak\discretionary{}{\hbox{$#1$}}{}}
\newtheorem{Lemma}{Лемма}
\theoremstyle{definiton}
\newtheorem{Remark}{Замечание}
%%\newtheorem{Def}{Определение}
\newtheorem{Claim}{Утверждение}
\newtheorem{Cor}{Следствие}
\newtheorem{Theorem}{Теорема}
\theoremstyle{definition}
\newtheorem{Example}{Пример}
\newtheorem*{known}{Теорема}
\def\proofname{Доказательство}
\theoremstyle{definition}
\newtheorem{Def}{Определение}

%% \newenvironment{Example} % имя окружения
%% {\par\noindent{\bf Пример.}} % команды для \begin
%% {\hfill$\scriptstyle\qed$} % команды для \end






%\date{22 июня 2011 г.}
\let\leq\leqslant
\let\geq\geqslant
\def\MT{\mathrm{MT}}
%Обозначения ``ажуром''
\def\BB{\mathbb B}
\def\CC{\mathbb C}
\def\RR{\mathbb R}
\def\SS{\mathbb S}
\def\ZZ{\mathbb Z}
\def\NN{\mathbb N}
\def\FF{\mathbb F}
%греческие буквы
\let\epsilon\varepsilon
\let\es\varnothing
\let\eps\varepsilon
\let\al\alpha
\let\sg\sigma
\let\ga\gamma
\let\ph\varphi
\let\om\omega
\let\ld\lambda
\let\Ld\Lambda
\let\vk\varkappa
\let\Om\Omega
\def\abstractname{}

\def\R{{\cal R}}
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}
\def\D{{\cal D}}

%классы сложности
\def\REG{{\mathsf{REG}}}
\def\CFL{{\mathsf{CFL}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%% Enumerations %%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Rnum}[1]{\expandafter{\romannumeral #1\relax}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

%%%%%%%%%%%%%%%%%%%%% EOF Enumerations %%%%%%%%%%%%%%%%%%%%%

\usepackage{xparse}
\usepackage{ifthen}
\usepackage{bm} %%% bf in math mode
\usepackage{color}
%\usepackage[usenames,dvipsnames]{xcolor}

\definecolor{Gray555}{HTML}{555555}
\definecolor{Gray444}{HTML}{444444}
\definecolor{Gray333}{HTML}{333333}


\newcounter{problem}
\newcounter{uproblem}
\newcounter{subproblem}
\newcounter{prvar}

\def\beforPRskip{
	\bigskip
	%\vspace*{2ex}
}

\def\PRSUBskip{
	\medskip
}


\def\pr{\beforPRskip\noindent\stepcounter{problem}{\bf \theproblem .\;}\setcounter{subproblem}{0}}
\def\pru{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^\circ$\!\!.\;}\setcounter{subproblem}{0}}
\def\prstar{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^*$\negthickspace.}\setcounter{subproblem}{0}\;}
\def\prpfrom[#1]{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem~(№#1 из задания).  }\setcounter{subproblem}{0} }
\def\prp{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem .  }\setcounter{subproblem}{0} }

\def\prpvar{\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem \;$\langle${\rm\Rnum{\theprvar}}$\rangle$.}\setcounter{subproblem}{0}\;}
\def\prpv{\beforPRskip\noindent\stepcounter{prvar}{\bf Задача \theproblem \,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$.  }\setcounter{subproblem}{0} }
\def\prv{\beforPRskip\noindent\stepcounter{prvar}{\bf \theproblem\,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}.\setcounter{subproblem}{0} }

\def\prpstar{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\bf\theproblem^*$\negthickspace.  }\setcounter{subproblem}{0} }
\def\prdag{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\theproblem^{^\dagger}$\negthickspace\,.  }\setcounter{subproblem}{0} }
\def\upr{\beforPRskip\noindent\stepcounter{uproblem}{\bf Упражнение \theuproblem.}\setcounter{subproblem}{0}\;}
%\def\prp{\vspace{5pt}\stepcounter{problem}{\bf Задача \theproblem .  } }
%\def\prs{\vspace{5pt}\stepcounter{problem}{\bf \theproblem .*   }
\def\prsub{\PRSUBskip\noindent\stepcounter{subproblem}{\sf \thesubproblem.}\;}
\def\prsubr{\PRSUBskip\noindent\stepcounter{subproblem}{\bf \asbuk{subproblem})}\;}
\def\prsubstar{\PRSUBskip\noindent\stepcounter{subproblem}{\rm $\thesubproblem^*$\negthickspace.}\;}
\def\prsubrstar{\PRSUBskip\noindent\stepcounter{subproblem}{$\text{\bf \asbuk{subproblem}}^*\mathbf{)}$}\;}

\newcommand{\bracketspace}[1]{\phantom{(}\!\!{#1}\!\!\phantom{)}}

\DeclareDocumentCommand{\Prpvar}{ O{null} O{} }{
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem
% 	\ifthenelse{\equal{#1}{null}}{  }{ {\sf $\bm\langle$\bracketspace{#1}$\bm\rangle$}}
%	~\!\!(\bracketspace{{\rm\Rnum{\theprvar}}}).  }\setcounter{subproblem}{0}
%	\;(\bracketspace{{\rm\Rnum{\theprvar}}})}\setcounter{subproblem}{0}
%
	\,{\sf $\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}}.

}
%\DeclareDocumentCommand{\Prpvar}{ O{level} O{meta} m }{\prpvar}


\DeclareDocumentCommand{\Prp}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача \theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

\DeclareDocumentCommand{\Pr}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf\theproblem
	~\!\! \ifthenelse{\equal{#1}{null}}{\!\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}
	
	\DeclareDocumentCommand{\Prstar}{ O{null} O{null} }{\setcounter{subproblem}{0}
			\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf$\mathbf{\theproblem^*}$
			~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
			 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}
	

%\DeclareDocumentCommand{\Prp}{ O{level} O{meta} }

\DeclareDocumentCommand{\Prps}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^* $
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}

\DeclareDocumentCommand{\Prpd}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^\dagger$
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}


\def\prend{
	\bigskip
%	\bigskip
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EOF Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%\usepackage{erewhon}
%\usepackage{heuristica}
%\usepackage{gentium}

\usepackage[portrait, top=3cm, bottom=1.5cm, left=3cm, right=2cm]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\lhead{\fontfamily{fca}\selectfont {AI Masters :: Алгоритмы 2022} }
%\lhead{ \bf  {ТРЯП. } Семинар 1 }
%\chead{\fontfamily{fca}\selectfont {Вариант 1}}
\rhead{\fontfamily{fca}\selectfont Домашнее задание 6}
%\rhead{\small 01.09.2016}
\cfoot{}

\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter {\setcounter{problem}{0}}  }{}{1em}{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Обозначения и операции %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
                                                                    
\newcommand{\divisible}{\mathop{\raisebox{-2pt}{\vdots}}}           
\let\Om\Omega


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Shen Macroses %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\w}[1]{{\hbox{\texttt{#1}}}}
\usepackage{wrapfig}
\def\bin{\mathrm{bin}}



\begin{document}	
	 \SetKwFunction{BuildMaxHeap}{Build\_Max\_Heap} 
	 \SetKwFunction{TreeSuccessor}{Tree\_Successor} 
	 \SetKwFunction{ExtMax}{Extract\_Max} 
	 \SetKwFunction{MaxHeapify}{Max\_Heapify}

		\SetKwInOut{Input}{Вход}\SetKwInOut{Output}{Выход}
		\SetKwProg{Fn}{Function}{ :}{end}
		\SetKwFunction{F}{F}
		\SetKwFunction{KWsize}{size}
		\SetKwFunction{HeapSize}{heap\_size}
			\SetKwFunction{KwPrint}{print} 
			\SetKwFunction{swap}{swap}
			
			\Pr[2] Реализуйте стек с помощью двух очередей.
            \newline
            \\ Стек должен поддерживать такие операции как push, pop, empty.
            \\ Опишем работу метода push. Будем хранить элементы всегда таким образом, что одна из очередей всегда пуста. При добавлении нового элемента, то есть вызова метода push, мы добавляем этот элемент в пустую очередь. А все элементы из второй очереди, если они там есть, добавляем в ту очередь, куда мы добавили новый элемент, таким образом делая вторую очередь пустой. Работать такой метод будет за O(n), где n - количество элементов в нашем "стеке".
            \\ Метод pop - будет просто брать элемент из непустой очереди. Работает за O(1).
            \\ Метод empty - проверяет обе очереди, пустые ли они.
            \\Корректность: так как очередь - это FIFO структура, то чтобы уметь выдавать последний элемент, надо класть этот последний элемент первым в очередь, что и реализуется в алгоритме. У нас сохраняется инвариант, что те элементы в стеке, которые пришли позже, всегда расположены раньше в очереди, чем те, которые пришли раньше в наш стек. Поэтому чтобы сделать pop, достаточно просто вытащить первый элемент из непустой очереди, так как он пришел позже всех. Метод push же устроен так, что сохраняет наш инвариант, так как одна из очередей уже по построению хранит все элементы в порядке, обратном к их порядку добавления, и мы лишь добавляем в пустую очередь новый элемент, а в конец добавляем все элементы из другой очереди, поэтому инвариант сохраняется.
            \\ Сложность указана в описании алгоритма.
%			\upr\!\!\!\!\footnote{Под упражнениями в ДЗ мы понимаем задачи, которые рекомендуем решить, но не требуем сдавать на проверку.} Процедура \BuildMaxHeap (второе издание Кормена) построения кучи с максимальным свойством работает за линейное время! Попробуйте доказать корректность этой процедуру и получить асимптотическую оценку, не читая доказательства из Кормена или попробуйте изучить доказательство.

			\Pr[2] Опишите способ хранения почти-полного троичного дерева в массиве. Как по номеру клетки родителя вычислить номера детей? Как по номеру ребёнка вычислить номер родителя?
			\newline
			\\ Рассмотрим почти полное дерево и нумерацию его узлов. Корню дадим число один, его детьми будут 2,3 и 4. На следующем уровне будут номера 5,6,7 - дети двойки, 8,9,10 - дети тройки и так далее. Заметим, что для каждого узла(кроме первого) выполняется следующее свойство: его номер можно представить как 3*k+c, где k - номер вершины родителя, а c - это число либо -1,либо 0, либо 1. Также заметим, что 3k+c+1 при делении нацело на 3 дает k, при любых с, описаных ранее.
			\\ Пусть у нас есть массив, построенный таким образом, что номер клетки массива заполнен узлом дерева с тем же номером. Таким образом, чтобы для какой-то клетки массива,например под номером i, найти родителя, нужно прибавить к ней единицу и поделить нацело на три, результат и будет номер клетки родителя: $(i+1) // 3$. Чтобы найти детей для какой-то клетки, например под номером j, мы умножаем этот номер на 3, и смотрим на клетки $3j-1,3j,3j+1$. Это и будут номера клеток детей.

			\medskip

			\noindent{\bf Преамбула.} Алгоритм удаления элемента из двоичного дерева поиска (Кормен II) использует вспомогательную процедуру~\TreeSuccessor, которая по узлу $x$ в двоичном дереве поиска находит следующий по возрастанию за $x$ элемент дерева. Разберитесь с тем как она работает и докажите её корректность~"--- в Кормене доказательство сведено к следующей задаче (упражнению для читателя). %реализован сложнее, чем алгоритм с лекции. Первый


			\Pr[4] Докажите, что если в бинарном дереве поиска у элемента $x$ нет правого ребёнка и у $x$ есть следующий за ним в порядке возрастания элемент~$y$, то $y$ является самым нижним предком\footnote{Предком вершины $x$ называют любую вершину, лежащую на пути в $x$ из корня.} $x$, чей левый дочерний узел так же является предком $x$ или самим~$x$.
			\newline
            \\Рассмотрим некоторый элемент х в бинарном дереве поиска. Если бы у него был правый ребенок, то следующим элементом по возрастанию после х был бы как раз этот ребенок, чо следует из построения бинарного дерева посика.
            \\ В нашем случае, правого ребенка нет. Тогда возможны два случая. Первый - сам х является левым ребенком некоторого узла $y$. В таком случае, следующим за ним по возрастанию будет его родитель. Это действительно так, так как промежуточных значений между х и его родителем не будет, из-за того, что у х не будет правого ребенка. Также, если рассмотреть поддерево с корнем в этом y, то оно будет содержать и $x$. А значит, оба элемента $x$ и $y$ будут одновременно либо больше, либо меньше своих общих предков и их других потомков, то есть между $x$ и $y$ не будет никаких значений. Также мы знаем, что путь от корня до элемента содержит родителя этого элемента, а родитель - самый нижний предок в пути.
            \\Второй случай - $х$ является правым ребенком. Таким образом, он больше своего родителя. Значит, надо смотреть на вершины выше. Если родитель $х$ тоже выше своего родителя, значит $х$ будет больше и своего деда, что следует из построения бинарного дерева поиска(элементы справа больше). Таким образом, надо подниматься еще выше, пока не дойдем до такого узла дерева, который будет левым ребенком своего родителя. Такой узел найдется из условия, что в дереве есть элемент больше $х$(если бы не нашелся такой узел, значит мы постоянно поднимались по предкам, каждый из которых меньше предыдущего, и так дошли бы до корня, который бы был меньше $х$, так как $х$ правый потомок корня, а двигаться выше было бы некуда). Так как узел является левым ребенком, то он меньше своего родителя. Более того, этот узел является корнем поддерева, которое находится слева от родителя корня, а соответственно все его элементы меньше родителя корня. Значит этот родитель и есть следующий элемент по взрастанию после $х$. Назовем этого родителя $y$. Промежуточных значений между ними нет, докажем это. Рассмотрим поддерево с корнем в $y$. Если оно является левым поддеревом, то значит оно меньше всех элементов среди родителя корня и правых детей родителя корня, а значит оба элемента $y$ и $x$ меньше их всех, и они не могут стоять между $x$ и $y$. Если это поддерево справа от родителя корня, то все элементы больше родителя $y$ и левых детей родителя $y$. Индуктивно, так можно рассматривать все элементы вплоть до корня. По алгоритму поиска, $y$ - элемент, который находится в пути от корня до $х$, причем самым нижним среди тех, который имеет левого ребенка. А значит, $y$ и его левый ребенок являются предками для $х$.
            \\Что и требовалось доказать.

			 \SetKwFunction{key}{key}
			\Pr[3] Покажите, что если вершина~$b$ в бинарном дереве поиска имеет две дочерние вершины, то последующая за ней вершина~$c$ не имеет левой дочерней вершины, а предшествующая ей вершина~$a$~"--- правой. Под предшествующей и последующей вершиной понимается, что $a.\key < b.\key < c.\key$ и в дереве поиска нет ключей в промежутках $(a.\key,b.\key)$ и $(b.\key,c.\key)$.
			\newline
			\\ Рассмотрим нашу тройку вершин $a$, $b$ и $c$, где $b$ - родитель $a$ и $с$.
			\\ По условию, в дереве нет таких вершин, которые бы лежали в промежутке (a.key,b.key). Допустим, что у вершины $a$ может быть правый ребенок, назовем его $x$. Но тогда по свойству бинарного дерева x.key > a.key, так как $x$ находится справа от $а$. Но вместе с тем, x.key < b.key, так как $x$ находится в левом поддереве вершины $b$. Из этого следует, что a.key<x.key<b.key. Но это противоречит условию, что между a.key и b.key нет промежуточных значений, значит у вершины $a$ нет правого ребенка.
			\\ Аналогично допускаем, что у вершины $c$ может быть левый ребенок, назовем его $y$. Но тогда y.key < c.key, а вместе с тем и y.key > b.key, так как $y$ находится в правом поддереве $b$. Это опять же противоречит требованиям, что между b.key и c.key нет никаких значений, следовательно у вершины $c$ нет левого ребенка.

			\Pr[3+5] В этой задаче требуется разработать структуру данных, удовлетворяющую описанным ниже ограничениям.
			В структуре данных будет храниться $k$-элементное подмножество $A$ множества из $n$ элементов. После того как в структуру данных будет загружено множество $A$, с помощью неё будет нужно проверить, принадлежит ли множеству~$A$ элемент $x$. Для этого можно совершить не более $t$ запросов к структуре, ответ на каждый из которых~"--- один бит.

			В структуре данных хранится двоичная строка~$w$, которая зависит от множества~$A$. Фактически разработка структуры данных состоит из описания двух алгоритмов. Первый получает на вход $n$ и подмножество $A$ и создаёт строку $w$. Второй получает на вход $n$ и элемент $x$, после чего может запросить произвольных $t$ битов строки~$w$ (или меньше), после чего определяет, принадлежит ли элемент~$x$ множеству $A$ или нет. При этом, второму алгоритму заранее неизвестна строка $w$.
			
			  Пусть $s(n,k,t)$~"--- минимальная длина строки $w$, которую достаточно отвести под такую структуру данных.

			\prsub Чему равно $s(n,k,1)$?
			\newline
			\\ Нужно за один запрос узнать, является ли $x$ элементом $A$. Это можно сделать, если строка w состоит из n символов, и 0 стоит на тех позициях строки, номера которых совпадают с теми элементами множества, которые не вошли в подмножество А. Иными словами, $w[i]=0$, если элемент i не входит в подмножество A, иначе $w[i]=1$. Таким образом, можно будет запросить бит под номером x, и если вернется 1, значит x входит в А, иначе нет.
			\\$s(n,k,1)=n$

			\prsub Найдите $\min\limits_t( s(n,k,t))$, при каком $t$ он достигается?
			\newline
			\\ Рассмотрим работу первого алгоритма, который создает строку w. У нас есть всего n элементов, соответственно, каждый может быть пронумерован двоичным числом, которое имеет длину $\log(n)$. Пусть алгоритм, создающий строку, складывает все двоичные номера элементов, попавшие в А, по модулю. То есть, просто применяет последовательно к ним операцию XOR. Результатом будет строка w,длиной $\log(n)$.
			\\ Пусть второму алгоритму разрешено делать не меньше $\log(n)$ запросов. Тогда он сможет узнать строку w. После этого, алгоритм должен сксорить узнанную строку c числом x. После этого, алгоритм должен взять всевозможные сочетания k-1 чисел из n-1 чисел, от 1 до n без x, и проксорить их с полученной ранее строкой. Если в какой-то из результатов получается по итогу нулевая строка, значит подмножество А содержит элемент x и те k-1 элементов с использованными k-1 номерами, которые при XOR со строкой w дают нулевую строку. Это происходит из-за того, что для любой бинарной строки выполняется z XOR z = 0. Строка w уже состоит из ксоров номеров элементов множества A, если сксорить с ними еще раз, то в результате как раз получится нулевая строка. Если же нулевой строки не получилось, значит x не содержится в множестве A.
			\\$\min\limits_t( s(n,k,t))=\log(n)$. Достигается при t = $\log(n)$

			\Pr[4][5.32 ДПВ] К серверу приходят одновременно $n$ клиентов. Для клиента $i$ известно время его обслуживания~$t_i$. Время ожидания клиента определяется как сумма времени обслуживания всех предыдущих клиентов и времени обслуживания его самого. К примеру, если обслуживает клиентов в порядке номеров, то время ожидания клиента~$i$ будет равно $\sum\limits_{j=1}^{i} t_j$. Постройте эффективный алгоритм, находящий последовательность обслуживания клиентов с минимальным суммарным временем ожидания клиентов.
			\newline
			\\ Рассмотрим некоторую последовательность клиентов $(a_1,..,a_n)$.
			\\ Время обслуживания у этих клиентов будет $(t_{a_1}, \sum\limits_{j=1}^{2} t_{a_j},..,\sum\limits_{j=1}^{n}t_{a_n})$.
			\\Суммарное время ожидания клиентов в таком случае будет: $t_{a_1} + \sum\limits_{j=1}^{2}+..+\sum\limits_{j=1}^{n}t_{a_n}=nt_{a_1}+(n-1)t_{a_2}+..+t_{a_n}=\sum\limits_{j=1}^{n}(n+1-j)t_{a_j}$
			\\ Как мы видим, время обслуживания первого клиента входит в общую сумму n раз, второго клиента - (n-1) раз и так далее. Поэтому, чтобы минимизировать суммарное время ожидания, мы должны обслуживать клиентов в порядке возрастания их времени обслуживания.Тогда наибольшее время обслуживания среди клиентов будет включено в общее время обслуживания лишь один раз, второе по максимуму - два раза, а самое малое - n раз, поэтому общее время обслуживания будет минимальным.
			\\Таким образом, чтобы найти последовательность обслуживания клиентов с минимальным суммарным временем ожидания клиентов, нужно отсортировать этих клиентов по времени обслуживания.
			\\Воспользуемся для сортировки алгоритмом heapsort. К нам изначально приходят n клиентов, мы знаем время их обслуживания, построим на клиентах кучу, что делается за $O(n)$. Далее, воспользуемся алгоритмом heapsort, который работает следующим образом: пусть куча реализована массивом. Ставим верхний элемент кучи на последнее место, таким образом максимальный элемент стоит в конце массива. За $\log(n)$ операций мы восстанавливаем свойства кучи на первых n-1 элементах, таким образом на верху кучи стоит второй по времени обслуживания клиент. Кладем его на n-1 место массива, и так далее. Таким образом, у нас получается отсортированный массив, время работы - $n\log(n)$, так как для каждого из n-1 случая перестановки элементов мы восстанавливаем свойства кучи за $\log(n)$. По итогу у нас получается алгоритм, который работает за $O(n\log(n))$.



%			\Prstar[null] Докажите, что любую программу, которая использует неограниченную оперативную память, можно реализовать на ограниченном компьютере, который использует конечную оперативную память и два неограниченных стека. Формально, программа имеет вход и выход, и потому реализует функцию~"--- нужно доказать, что эта функция реализуема и на ограниченном компьютере. Такие функции называются \emph{вычислимыми}.
			
			
			
\end{document}
  