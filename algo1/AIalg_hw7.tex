\documentclass[12pt]{extreport}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}        % Кодировка входного документа;
                                    % при необходимости, вместо cp1251
                                    % можно указать cp866 (Alt-кодировка
                                    % DOS) или koi8-r.

\usepackage[english,russian]{babel} % Включение русификации, русских и
                                    % английских стилей и переносов
%%\usepackage{a4}
%%\usepackage{moreverb}
\usepackage{amsmath,amsfonts,amsthm,amssymb,amsbsy,amstext,amscd,amsxtra,multicol}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning}
\usepackage{multicol} %Несколько колонок
\usepackage{graphicx}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[stable]{footmisc}

\usepackage[linesnumbered]{algorithm2e}   

%% \voffset-5mm
%% \def\baselinestretch{1.44}
\renewcommand{\theequation}{\arabic{equation}}
\def\hm#1{#1\nobreak\discretionary{}{\hbox{$#1$}}{}}
\newtheorem{Lemma}{Лемма}
\theoremstyle{definiton}
\newtheorem{Remark}{Замечание}
%%\newtheorem{Def}{Определение}
\newtheorem{Claim}{Утверждение}
\newtheorem{Cor}{Следствие}
\newtheorem{Theorem}{Теорема}
\theoremstyle{definition}
\newtheorem{Example}{Пример}
\newtheorem*{known}{Теорема}
\def\proofname{Доказательство}
\theoremstyle{definition}
\newtheorem{Def}{Определение}

%% \newenvironment{Example} % имя окружения
%% {\par\noindent{\bf Пример.}} % команды для \begin
%% {\hfill$\scriptstyle\qed$} % команды для \end






%\date{22 июня 2011 г.}
\let\leq\leqslant
\let\geq\geqslant
\def\MT{\mathrm{MT}}
%Обозначения ``ажуром''
\def\BB{\mathbb B}
\def\CC{\mathbb C}
\def\RR{\mathbb R}
\def\SS{\mathbb S}
\def\ZZ{\mathbb Z}
\def\NN{\mathbb N}
\def\FF{\mathbb F}
%греческие буквы
\let\epsilon\varepsilon
\let\es\varnothing
\let\eps\varepsilon
\let\al\alpha
\let\sg\sigma
\let\ga\gamma
\let\ph\varphi
\let\om\omega
\let\ld\lambda
\let\Ld\Lambda
\let\vk\varkappa
\let\Om\Omega
\def\abstractname{}

\def\R{{\cal R}}
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}
\def\D{{\cal D}}

%классы сложности
\def\REG{{\mathsf{REG}}}
\def\CFL{{\mathsf{CFL}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%% Enumerations %%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Rnum}[1]{\expandafter{\romannumeral #1\relax}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

%%%%%%%%%%%%%%%%%%%%% EOF Enumerations %%%%%%%%%%%%%%%%%%%%%

\usepackage{xparse}
\usepackage{ifthen}
\usepackage{bm} %%% bf in math mode
\usepackage{color}
%\usepackage[usenames,dvipsnames]{xcolor}

\definecolor{Gray555}{HTML}{555555}
\definecolor{Gray444}{HTML}{444444}
\definecolor{Gray333}{HTML}{333333}


\newcounter{problem}
\newcounter{uproblem}
\newcounter{subproblem}
\newcounter{prvar}

\def\beforPRskip{
	\bigskip
	%\vspace*{2ex}
}

\def\PRSUBskip{
	\medskip
}


\def\pr{\beforPRskip\noindent\stepcounter{problem}{\bf \theproblem .\;}\setcounter{subproblem}{0}}
\def\pru{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^\circ$\!\!.\;}\setcounter{subproblem}{0}}
\def\prstar{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^*$\negthickspace.}\setcounter{subproblem}{0}\;}
\def\prpfrom[#1]{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem~(№#1 из задания).  }\setcounter{subproblem}{0} }
\def\prp{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem .  }\setcounter{subproblem}{0} }

\def\prpvar{\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem \;$\langle${\rm\Rnum{\theprvar}}$\rangle$.}\setcounter{subproblem}{0}\;}
\def\prpv{\beforPRskip\noindent\stepcounter{prvar}{\bf Задача \theproblem \,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$.  }\setcounter{subproblem}{0} }
\def\prv{\beforPRskip\noindent\stepcounter{prvar}{\bf \theproblem\,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}.\setcounter{subproblem}{0} }

\def\prpstar{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\bf\theproblem^*$\negthickspace.  }\setcounter{subproblem}{0} }
\def\prdag{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\theproblem^{^\dagger}$\negthickspace\,.  }\setcounter{subproblem}{0} }
\def\upr{\beforPRskip\noindent\stepcounter{uproblem}{\bf Упражнение \theuproblem.}\setcounter{subproblem}{0}\;}
%\def\prp{\vspace{5pt}\stepcounter{problem}{\bf Задача \theproblem .  } }
%\def\prs{\vspace{5pt}\stepcounter{problem}{\bf \theproblem .*   }
\def\prsub{\PRSUBskip\noindent\stepcounter{subproblem}{\sf \thesubproblem.}\;}
\def\prsubr{\PRSUBskip\noindent\stepcounter{subproblem}{\bf \asbuk{subproblem})}\;}
\def\prsubstar{\PRSUBskip\noindent\stepcounter{subproblem}{\rm $\thesubproblem^*$\negthickspace.}\;}
\def\prsubrstar{\PRSUBskip\noindent\stepcounter{subproblem}{$\text{\bf \asbuk{subproblem}}^*\mathbf{)}$}\;}

\newcommand{\bracketspace}[1]{\phantom{(}\!\!{#1}\!\!\phantom{)}}

\DeclareDocumentCommand{\Prpvar}{ O{null} O{} }{
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem
% 	\ifthenelse{\equal{#1}{null}}{  }{ {\sf $\bm\langle$\bracketspace{#1}$\bm\rangle$}}
%	~\!\!(\bracketspace{{\rm\Rnum{\theprvar}}}).  }\setcounter{subproblem}{0}
%	\;(\bracketspace{{\rm\Rnum{\theprvar}}})}\setcounter{subproblem}{0}
%
	\,{\sf $\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}}.

}
%\DeclareDocumentCommand{\Prpvar}{ O{level} O{meta} m }{\prpvar}


\DeclareDocumentCommand{\Prp}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача \theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

\DeclareDocumentCommand{\Pr}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf\theproblem
	~\!\! \ifthenelse{\equal{#1}{null}}{\!\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}
	
	\DeclareDocumentCommand{\Prstar}{ O{null} O{null} }{\setcounter{subproblem}{0}
			\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf$\mathbf{\theproblem^*}$
			~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
			 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}
	

%\DeclareDocumentCommand{\Prp}{ O{level} O{meta} }

\DeclareDocumentCommand{\Prps}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^* $
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}

\DeclareDocumentCommand{\Prpd}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^\dagger$
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}


\def\prend{
	\medskip
%	\bigskip
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EOF Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%\usepackage{erewhon}
%\usepackage{heuristica}
%\usepackage{gentium}

\usepackage[portrait, top=3cm, bottom=1.5cm, left=3cm, right=2cm]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\lhead{\fontfamily{fca}\selectfont {AI Masters :: Алгоритмы 2022} }
%\lhead{ \bf  {ТРЯП. } Семинар 1 }
%\chead{\fontfamily{fca}\selectfont {Вариант 1}}
\rhead{\fontfamily{fca}\selectfont Домашнее задание 7}
%\rhead{\small 01.09.2016}
\cfoot{}

\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter {\setcounter{problem}{0}}  }{}{1em}{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Обозначения и операции %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
                                                                    
\newcommand{\divisible}{\mathop{\raisebox{-2pt}{\vdots}}}           
\let\Om\Omega


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Shen Macroses %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\w}[1]{{\hbox{\texttt{#1}}}}
\usepackage{wrapfig}
\def\bin{\mathrm{bin}}

\def\H{{\cal H}}

\begin{document}	
	 \noindent\textbf{Преамбула.} Поскольку мы изучили хеш-таблицы, операции в которых стоят $O(1)$ за счёт использования вероятности, хотя в худшем случае это не так, в этом задании (и далее по умолчанию) мы считаем, что когда требуется найти алгоритм со сложностью $O(f(n))$, операции с хеш-таблицами при их использовании стоят $O(1)$.

	 \Pr[3] В языке C++ структура данных \texttt{std::set} реализована с помощью красно-чёрных деревьев. В ней хранится множество ключей, при этом считается, что ключи упорядочены. Помимо стандартных операций (вставки, поиска, удаления), которые стоят $O(\log n)$, где $n$~"--- число элементов в структуре данных, эта структура данных позволяет вывести все элементы в отсортированном порядке за $O(n)$. Опишите, как модифицировать красно-чёрное дерево так, чтобы сделать возможным такой вывод и не изменить стоимость стандартных операций. Считайте, что балансировка дерева после добавления и удаления элемента стоит $O(\log n)$.

	 \medskip

	 Семейство хеш-функций $\H$ называется \emph{универсальным}, если для любых фиксированных различных $x$ и $y$ вероятность события $f(x)=f(y)$ равна $1/m$, где $f$ выбирается случайно и равновероятно из $\H$ и отображает $n$-элементное множество (пространтство ключей) в $m$-элементное множество.

	 \medskip


	 \Pr[2] Семейство хеш-функций $H = \{f,g,h\}$, отображающих множество ключей $\{0,1,2,3\}$ в множество хешей $\{0,1,2\}$, задано таблицей. Является ли оно универсальным?
     
	 \medskip


	 \begin{tabular}{|c|c|c|c|}
	 \hline
	 ключи&значения $f$&значения $g$&значения $h$\\
	 \hline
	 0&0&1&0\\
	 \hline
	 1&0&2&2\\
	 \hline
	 2&1&2&2\\
	 \hline
	 3&1&1&0\\
	 \hline
	 \end{tabular}
	 \newline 
     \\ Рассмотрим значения 0 и 2. Значения в этих точках у функций f,g и h равны (0, 1), (1, 2), (0, 2). Отсюда понятно, что вероятность $m(x)=m(y)$ равна 0, где $m \in {f,g,h}$.
     \\ Более того, можно рассмотреть значения 1 и 2. Значения функций в этих точках будут равны (0,1), (2,2), (2,2). То есть вероятность, что $m(x)=m(y)$ равна 2/3.
     \\ Из выше показаного следует, что не выполняется условие универсальности.

	 \prend

	 \Pr[3] В структуре данных <<динамический массив>> (в C++ \texttt{std::vector}) удаление $k$-го элемента стоит $O(n-k)$, где $n$~"--- количество элементов в массиве. Это происходит за счёт сдвигов: необходимо, чтобы первый элемент динамического массива находился в первой ячейке выделенной под массив памяти, а также нужно, чтобы между соседними элементами не было пустых ячеек памяти. Поэтому после очищения $k$-ой ячейки в результате удаления требуется последовательно сдвинуть $n-k$ последних элементов на единицу влево.

	 Так, удаление последнего элемента стоит $O(1)$, поэтому с помощью динамических масивов стандартно реализует стеки, а удаление первого элемента стоит $O(n)$, поэтому использовать динамические массивы для наивной реализации очереди (при извлечении из очереди первый элемент извлекают из массива, а потом удаляют, а новые элементы добавляются в конец массива)~"--- не лучшее решение.

	 Однако, с помощью динамического массива можно эффективно реализовать очередь поплатившись двукратным увеличением памяти. % Пусть известно, что одновременное максимальное число элементов в очереди $n$.
	  Как и в случае наивной реализации, элементы будут извлекаться из начала массива $A$, а добавляться будут в его конец. Заведём указатель (целочисленная перменная $b$), который сначала указывает на первый элемент массива ($b=0$). Когда требуется извлечь элемент из очереди, сам элемент физически удаляться не будет, а будет увеличиваться лишь указатель: при извлечении из очереди возвращается элемент $A[b]$, после чего $b$ увеличивается на единицу. В каждый момент, когда $b \geq \lfloor \frac{n}{2} \rfloor$ ($n$~"--- число элементов в массиве $A$), происходит удаление $b$ элементов из массива, после чего $b$ присваивается значение~$0$.
 
	 Уточните описанный выше алгоритм так, чтобы в результате $n$ любых запросов к структуре данных <<очередь>> выполнялось $O(n)$ операций и при этом выделяемая под динамический массив память не превосходила удвоенную память, требуемую для хранения очереди.

	 \textbf{Указание}. Для доказательства оценки используйте амортизационный анализ.

	 \prend

	 \Pr[3] Опишите реализацию структуры данных <<очередь с приоритетами>> (из классного листка) со следующими стоимостями операций 

	 \begin{itemize}
	 	\item \texttt{insert}~"--- $O(1)$,
	 		\item \texttt{extract\_max}~"--- $O(n)$, 	\item \texttt{set\_priority}~"--- $O(1)$. 
	 \end{itemize}
При этом известно, что все ключи~"--- уникальные числа в диапазоне от $1$ до $n$.
    \newline
    \\ Будем использовать для хранения пар $(key,p)$, где key - ключ, а p - приоритет, хэш-таблицу.
    \\ Insert будет работать за $O(1)$, берем хэш от ключа и в качестве значения будем класть приоритет.
    \\ Set\_priority тоже будет работать за $O(1)$. Надо обратиться по ключу(точнее по его хэшу) к хранящемуся значению, и перезаписать его, поставив новый приоритет.
    \\ Опишем работу extract\_max. Чтобы найти максимальное значение по приоритету, пройдемся по всем ключам в хэш таблице. При проходе будем хранить переменную, которая будет содержать наибольшее значение среди тех элементов хэш-таблицы, которые были рассмотрены. После прохода, данная переменная будет хранить наибольшее значение приоритета. Проход по всем значениям хэш-таблицы занимает $O(n)$ операций.
	 \prend


	 \Pr[2+2] В массиве размера $n$ хранятся повторяющиеся ключи; можно считать, что ключ~"--- это число (возможно достаточно большое). 
	 
	 \prsub Постройте алгоритм, который выводит пары из уникального ключа и числа вхождений ключа в массив в порядке возрастания числа вхождений.
	 
	 \prsub Постройте алгоритм, который решает задачу со сложностью $O(n)$ (достаточно решить только этот пункт).
	 \newline
	 \\ Для решения задачи будем использовать две хэш-таблицы.
	 \\ Для начала заполним первую хэш-таблицу. Сделаем один проход по массиву, и будем действовать следующим образом: если элемент массива отсутствует как ключ в хэш-таблице, кладем в хэш-таблицу значение 1 по хэшу данного элемента, иначе же мы берем значение по хэшу текушего элемента массива и увеличиваем его на 1. Таким образом у нас будет хэш-таблица, которая в качестве ключе содержит элементы массива, а в качестве значений - их частоты в массиве.
	 \\ Затем заполним вторую хэш таблицу. Сделаем проход по первой хэш-таблице, будем доставать оттуда пары (element, frequency) и класть их во вторую хэш-таблицу, но наоборот, то есть в качестве ключа будем использовать frequency, а в качестве значения класть element. Таким образом, у нас будет сформирована хэш-таблица, которая по частотам хранит элементы с этой частотой. 
	 \\ Возможна такая ситуация, что несколько элементов имеют одинаковую частоту. Тогда при заполнении второй хэш-таблицы мы по этой частоте будем хранить список элементов с такой частотой.
	 \\После построения второй хэш-таблицы, нам осталось сделать по ней проход, и вывести все элементы по тем ключам, которые присутствуют.
	 \\ Так как у нас массив из n элементов, то частота элементов не может превосходить n. Более того, у каждого элемента - одна частота, то есть в качестве значения в хэш-таблице элемент массива встречается лишь раз. Таким образом, достаточно сделать цикл от 1 до n, для каждого значения от 1 до n проверить, есть ли оно в качестве ключа в хэш-мапе, и если есть, то вывести все элементы с такой частотой. В итоге получим последовательность элементов, отсортированную по частоте.
	 \\ Алгоритм делает 3 прохода: 1 один раз по массиву длиной n, по 1 разу по двум хэш-таблицам, которые не превосходят длины n. Таким образом, сложность алгоритма $O(n)$.

	 \prend

	 \Pr[5] Постройте алгоритм, который получив на вход числовой массив выводит количество его подмассивов (непрерывных подпоследовтаельностей), в которых все элементы различны.
	 \newline
	 \\ Для начала посчитаем, сколько непрерывных подмассивов есть в массиве длиной k. Для k=2 это число равно 3 - два подмассива длиной один и один подмассив длины 2, который совпадает с самим массивом. $3 = \frac{2*3}{2} = \frac{k*(k+1)}{2}$. Докажем по индукции, что действительно, в массиве длины k есть $\frac{k*(k+1)}{2}$ непрерывных подмассивов. Мы показали для длины k=2. Пусть верно для длины l. Покажем, что верно и для длины l+1. Возьмем первые l элементов. Они уже дают $\frac{l*(l+1)}{2}$. Последний элемент входит в подмассив длины 1, в подмассив длины 2, который образуется последним и предпоследними элементами, и так далее. Таким образом, последний элемент входит в l+1 непрерывных подмассивов. Таким образом, $\frac{l*(l+1)}{2} + l + 1 = \frac{l^2+l + 2l + 2)}{2} = \frac{(l+2)(l+1)}{2}$. Ч.т.д.
	 \\ Заведем хэш-таблицу и очередь. Заведем два указателя, первый будет указывать на начало текущего подмассива, второй будет двигаться вправо по массиву до тех пор, пока не встретиться элемент, который уже присутствует в текущем подмассиве. Назовем их l1 и l2. Также заведем переменную, которая будет хранить количество непрерывных подмассивов, назовем ее result. В начале работы алгоритма ее значение равно 0.
	 \\Начнем проход по массиву, будем добавлять каждый элемент и в хэш-таблицу, и в очередь. В какой-то момент случится так, что мы попытаемся положить элемент в хэш-таблицу, а он там уже есть, это значит, что этот элемент уже встречался ранее в массиве. У нас есть указатель l1, указывающий на начало подмассива, и на текущий элемент.То есть в подмассиве от l1 до l2, не включая текущий элемент, нет повторений. Посчитаем количество непрерывных подмассивов в нашем исходном подмассиве по формуле выше. Так как все элементы различны в исходном подмассиве, то и в его подмассивах будут уникальные элементы. Добавим это количество в result.
	 \\ После этого начнем удалять элементы из очереди и соответствующие им элементы из хэш-таблицы до тех пор, пока не наткнемся на тот элемент, который совпадает с текущим. Выкидываем его из очереди, кладем текущий в очередь. Вместе с удалением элемента из очереди, будем сдвигать l1 вправо. Таким образом, l1 будет указывать на элемент, который находится за последним из удаленных из очереди. Посчитаем количество неперывных подмассивов в подмассиве, границами которого являются новое положение l1 и l2, опять же, не включая текущий элемент. Вычтем это количество из result. Потом алгоритм продолжит сдвигать l2 вправо, до тех пор, пока не встретит уже встречавшийся элемент, и так далее.
	 \\ Когда указатель l2 дойдет до конца массива, остается посчитать количество непрерывных подмассивов от l1 до l2 по формуле выше, добавить это количество к result, и вывести result. На этом алгоритм окончит работу.
	 \\Корректность. Во-первых заметим, что сохраняется инвариант - между l1 и l2 нету повторяющихся элементов. Поэтому в result записываются только подмассивы с уникальными элементами. Теперь покажем, что все подмассивы учитываются в result. Если массив состоит из уникальных элементов, то алгоритм очевидно отработает корректно, просто посчитает ответ по формуле выше. Рассмотрим случай, когда есть повторяющийся элемент: у нас есть два подмассива исходного массива, которые содержат уникальные элементы. Назовем повторяющийся элемент T. Тогда первый подмассив - это между началом массива и вторым вхождением T, а второй - от первого вхождения T - до конца массива. Как видно, у этих подмассивов есть пересечение. Поэтому, если просто посчитать ответ как сумму ответов от этих двух подмассивов, то мы учтем подмассивы на пересечении два раза, поэтому их надо вычесть из суммы ответов подмассивов. Что и делается в алгоритме, таким образом количество подмассивов считается корректно.
	 \\ Сложность. Каждый элемент массива мы добавляем в очередь, и если понадобится, удаляем. Также мы добавляем 1 раз в хэш-таблицу, и если надо, удаляем оттуда. Таким образом, с каждым элементом мы взаимодействуем максимум 4 раза. Операции вычисления подмассивов работают за $O(1)$, вычисляем мы не более n раз. Таким образом, работа алгоритма не превышает $O(n)$.


	 \prend

	 \Pr[4] Структура данных <<таблица>> представляет собой числовую матрицу размера $m\times n$ (двумерный массив), элементы которой в каждой строке и каждом столбце отсортированы по возрастанию. В случае, если в таблице меньше $mn$ элементов, в незаполненных клетках написано $\infty$.

	 \prsub Постройте алгоритм, который проверяет находит элемент $x$ в  частично заполненную таблицу за $O(m+n)$ или проверяет, что такого элемента в таблице нет.
	 \newline
	 \\Начнем поиск элемента $x$ с верхнего правого элемента. Будем пользоваться тем свойством, что строки и столбцы отсортированы. Начнем сравнивать $x$ с текущим элементом матрицы, если $x$ больше, то сдвигаемся на элемент вниз, если меньше, то двигаемся влево. Алгоритм работает до тех пор, пока не находит элемент, равный $x$ или пока не доходит до границы матрицы, значит такого элемента в матрице нет.
	 \\Корректность. Если $x$ меньше текущего элемента матрицы, то значит все элементы справа и снизу больше $x$, поэтому надо двигаться влево(вверх не надо, так как мы итак ищем сверху вниз, и если мы спустились вниз, значит все элементы выше и левее предыдущей позиции меньше $x$). Если $x$ больше текущего элемента, то все элементы левее и выше меньше $x$, поэтому надо двигаться вниз(вправо не надо, так как если мы двинулись влево, значит все элементы правее и ниже предыдщей позиции, больше $x$).Таким образом, мы каждый раз отсекаем только те элементы, которые меньше или больше $x$.
	 \\ Сложность. В процесс поиска элемента $x$ в матрице, мы сдвинемся не более m+n раз, так как двигаемся только вниз или влево. Таким образом, сложность $O(m+n)$.

	 \prsub Постройте алгоритм, вставляющий новый элемент в частично заполненную таблицу за $O(m+n)$.
	 \newline
	 \\ Вставим элемент вместо самого правого верхнего $\infty$. Теперь надо поставить элемент на нужное место. Так как мы поставили элемент вместо самого правого верхнего $\infty$, то сверху от нового элемента будут только нормальные элементы(то есть не $\infty$). Будем двигать элемент сначала влево или вверх. Под двигать вверх подразумевается смена нашего элемента и элемента выше местами. Аналогчино с другими направлениями. Смотрим на элементы слева и сверху от нашего, и движемся в ту сторону, где элемент больше, то есть max(left\_elem, upper\_elem). В какой-то момент, будет ситуация, когда слева элемент будет меньше. С текущей позиции элемент можно больше не двигать вверх, так как сверху либо нет элементов, либо все они меньше нашего элемента, что вытекает из свойств матрицы.
	 \\ Затем будем менять новый элемент с элементом слева местами до тех пор, пока слева не окажется элемент, меньше нового. Зафиксируем пока позицию нашего элемента.
	 \\ Теперь рассмотрим возможные ситуации. Ситуация, когда наш элемент меньше элемента слева, но больше, чем снизу, невозможна, так как противоречит свойствам матрицы. Так как элемент снизу больше чем элемент, который больше элемента слева от нашего элемента.
	 \\Если новый элемент больше, чем элемент снизу, то мы меняем местами наш элемент и элемент снизу местами.
	 \\ Если новый элемент меньше, чем элемент снизу и меньше, чем элемент слева, то мы меняем местами наш элемент и элемент слева местами.
	 \\ Если новый элемент меньше, чем элемент снизу и больше, чем элемент слева, то мы нашли подходящую позицию, и алгоритм останавливает поиск.
	 \\ Если мы дошли до самого левого столбца, то двигаем элемент вниз, пока снизу не окажется элемент больше, если дошли до самой нижней строки, то двигаемся влево до тех пор, пока слева не окажется элемент меньше нашего.
	 \\Корректность. Во время поиска элементы не нарушают свойство матрицы.
	 \\ Сложность - мы прошли вверх и вниз по 1 разу, и двигались только вправо. Таким образом, сложность не превышает $O(n+m)$
	 

	 \prsubstar Постройте алгоритм, который удаляет элемент из частично заполненной таблицы за \mbox{$O(m+n)$}.

	 \prend
			
			
\end{document}
  