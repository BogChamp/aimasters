\documentclass[12pt]{extreport}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}        % Кодировка входного документа;
                                    % при необходимости, вместо cp1251
                                    % можно указать cp866 (Alt-кодировка
                                    % DOS) или koi8-r.

\usepackage[english,russian]{babel} % Включение русификации, русских и
                                    % английских стилей и переносов
%%\usepackage{a4}
%%\usepackage{moreverb}
\usepackage{amsmath,amsfonts,amsthm,amssymb,amsbsy,amstext,amscd,amsxtra,multicol}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning}
\usepackage{multicol} %Несколько колонок
\usepackage{graphicx}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[stable]{footmisc}

\usepackage[linesnumbered]{algorithm2e}   

%% \voffset-5mm
%% \def\baselinestretch{1.44}
\renewcommand{\theequation}{\arabic{equation}}
\def\hm#1{#1\nobreak\discretionary{}{\hbox{$#1$}}{}}
\newtheorem{Lemma}{Лемма}
\theoremstyle{definiton}
\newtheorem{Remark}{Замечание}
%%\newtheorem{Def}{Определение}
\newtheorem{Claim}{Утверждение}
\newtheorem{Cor}{Следствие}
\newtheorem{Theorem}{Теорема}
\theoremstyle{definition}
\newtheorem{Example}{Пример}
\newtheorem*{known}{Теорема}
\def\proofname{Доказательство}
\theoremstyle{definition}
\newtheorem{Def}{Определение}

%% \newenvironment{Example} % имя окружения
%% {\par\noindent{\bf Пример.}} % команды для \begin
%% {\hfill$\scriptstyle\qed$} % команды для \end






%\date{22 июня 2011 г.}
\let\leq\leqslant
\let\geq\geqslant
\def\MT{\mathrm{MT}}
%Обозначения ``ажуром''
\def\BB{\mathbb B}
\def\CC{\mathbb C}
\def\RR{\mathbb R}
\def\SS{\mathbb S}
\def\ZZ{\mathbb Z}
\def\NN{\mathbb N}
\def\FF{\mathbb F}
%греческие буквы
\let\epsilon\varepsilon
\let\es\varnothing
\let\eps\varepsilon
\let\al\alpha
\let\sg\sigma
\let\ga\gamma
\let\ph\varphi
\let\om\omega
\let\ld\lambda
\let\Ld\Lambda
\let\vk\varkappa
\let\Om\Omega
\def\abstractname{}

\def\R{{\cal R}}
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}
\def\D{{\cal D}}

%классы сложности
\def\REG{{\mathsf{REG}}}
\def\CFL{{\mathsf{CFL}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%% Enumerations %%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Rnum}[1]{\expandafter{\romannumeral #1\relax}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

%%%%%%%%%%%%%%%%%%%%% EOF Enumerations %%%%%%%%%%%%%%%%%%%%%

\usepackage{xparse}
\usepackage{ifthen}
\usepackage{bm} %%% bf in math mode
\usepackage{color}
%\usepackage[usenames,dvipsnames]{xcolor}

\definecolor{Gray555}{HTML}{555555}
\definecolor{Gray444}{HTML}{444444}
\definecolor{Gray333}{HTML}{333333}


\newcounter{problem}
\newcounter{uproblem}
\newcounter{subproblem}
\newcounter{prvar}

\def\beforPRskip{
	\bigskip
	%\vspace*{2ex}
}

\def\PRSUBskip{
	\medskip
}


\def\pr{\beforPRskip\noindent\stepcounter{problem}{\bf \theproblem .\;}\setcounter{subproblem}{0}}
\def\pru{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^\circ$\!\!.\;}\setcounter{subproblem}{0}}
\def\prstar{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^*$\negthickspace.}\setcounter{subproblem}{0}\;}
\def\prpfrom[#1]{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem~(№#1 из задания).  }\setcounter{subproblem}{0} }
\def\prp{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem .  }\setcounter{subproblem}{0} }

\def\prpvar{\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem \;$\langle${\rm\Rnum{\theprvar}}$\rangle$.}\setcounter{subproblem}{0}\;}
\def\prpv{\beforPRskip\noindent\stepcounter{prvar}{\bf Задача \theproblem \,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$.  }\setcounter{subproblem}{0} }
\def\prv{\beforPRskip\noindent\stepcounter{prvar}{\bf \theproblem\,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}.\setcounter{subproblem}{0} }

\def\prpstar{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\bf\theproblem^*$\negthickspace.  }\setcounter{subproblem}{0} }
\def\prdag{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\theproblem^{^\dagger}$\negthickspace\,.  }\setcounter{subproblem}{0} }
\def\upr{\beforPRskip\noindent\stepcounter{uproblem}{\bf Упражнение \theuproblem .  }\setcounter{subproblem}{0} }
%\def\prp{\vspace{5pt}\stepcounter{problem}{\bf Задача \theproblem .  } }
%\def\prs{\vspace{5pt}\stepcounter{problem}{\bf \theproblem .*   }
\def\prsub{\PRSUBskip\noindent\stepcounter{subproblem}{\sf \thesubproblem .} }
\def\prsubr{\PRSUBskip\noindent\stepcounter{subproblem}{\bf \asbuk{subproblem})}\;}
\def\prsubstar{\PRSUBskip\noindent\stepcounter{subproblem}{\rm $\thesubproblem^*$\negthickspace.  } }
\def\prsubrstar{\PRSUBskip\noindent\stepcounter{subproblem}{$\text{\bf \asbuk{subproblem}}^*\mathbf{)}$}\;}

\newcommand{\bracketspace}[1]{\phantom{(}\!\!{#1}\!\!\phantom{)}}

\DeclareDocumentCommand{\Prpvar}{ O{null} O{} }{
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem
% 	\ifthenelse{\equal{#1}{null}}{  }{ {\sf $\bm\langle$\bracketspace{#1}$\bm\rangle$}}
%	~\!\!(\bracketspace{{\rm\Rnum{\theprvar}}}).  }\setcounter{subproblem}{0}
%	\;(\bracketspace{{\rm\Rnum{\theprvar}}})}\setcounter{subproblem}{0}
%
	\,{\sf $\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}}.

}
%\DeclareDocumentCommand{\Prpvar}{ O{level} O{meta} m }{\prpvar}


\DeclareDocumentCommand{\Prp}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача \theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

\DeclareDocumentCommand{\Pr}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf\theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

%\DeclareDocumentCommand{\Prp}{ O{level} O{meta} }

\DeclareDocumentCommand{\Prps}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^* $
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}

\DeclareDocumentCommand{\Prpd}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^\dagger$
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}


\def\prend{
	\bigskip
%	\bigskip
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EOF Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%\usepackage{erewhon}
%\usepackage{heuristica}
%\usepackage{gentium}

\usepackage[portrait, top=3cm, bottom=1.5cm, left=3cm, right=2cm]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\lhead{\fontfamily{fca}\selectfont {AI Masters :: Алгоритмы 2022} }
%\lhead{ \bf  {ТРЯП. } Семинар 1 }
%\chead{\fontfamily{fca}\selectfont {Вариант 1}}
\rhead{\fontfamily{fca}\selectfont Домашнее задание 5}
%\rhead{\small 01.09.2016}
\cfoot{}

\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter {\setcounter{problem}{0}}  }{}{1em}{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Обозначения и операции %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
                                                                    
\newcommand{\divisible}{\mathop{\raisebox{-2pt}{\vdots}}}           
\let\Om\Omega


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Shen Macroses %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\w}[1]{{\hbox{\texttt{#1}}}}
\usepackage{wrapfig}
\def\bin{\mathrm{bin}}



\begin{document}	
	

	\Pr[2] Дано $n$ слов длины $k$, состоящих из маленьких букв латинского алфавита. Предложите эффективный алгоритм их сортировки в лексикографическом (словарном) порядке.
	\newline
	\\ Будем использовать Radix Sort.
	\\ Каждое слово можно считать массивом длины k. Таким образом, перед нами задача сортировки n массивов, каждый из которых длины k. Слова состоят из букв, множество букв ограничено, их всего 26 в алфавите. Таким образом, нам нужно будет сравнивать между собой вектора, элементы которых будем воспринимать как символы в 26-ичной системе счисления. Будем сортировать слова поразрядно. Сначала отсортируем по последним буквам, затем по предпоследним, и так далее. Для сортировки будем использовать алгоритм Counting sort. Алгоритм закончит работу после сортировки по первой букве всех слов.
	\\Корректность: Благодаря тому, что мы сортируем слова по буквам с конца, то при сортировке очередного разряда, у нас сохраняется порядок тех слов, которые имеют одинаковое значение в текущем разряде, что называется stable sort. Это свойство имеется благодаря сортировке Counting sort. А так как слова нужно сортировать в лексикографическом порядке, то если у двух слов одинаковое значение в каком-то разряде, то их взаимное положение будет зависеть от меньших разрядов, и то, у кого массив меньших разрядов меньше, тот и должен стоять раньше. Благодаря тому, что мы сортируем с конца разрядов, это свойство как раз и выполняется в нашей сортировке. Поэтому сортировка корректна.
	\\ Что касается сложности, то сложность Counting sort в нашем случае равна O(n+26), у слова k разрядов, поэтому итоговая сложность: O((n+26)*k)=O(n*k)

	\Pr[3] Пусть числовой массив $a[1],\dots,a[n]$ строго унимодален на максимум. Это означает, что существует $t$, такое что
	$$
	a[1]<a[2]<\dots< a[t]> a[t+1]>\dots> a[n-1]> a[n],
	\quad 1\leq t\leq n.
	$$

	\prsub Разрешается за один ход спросить значение одного элемента массива.
	Докажите, что можно найти значение максимального элемента $a[t]$ за
	не более $O(\log n)$ ходов.
	\newline
	\\ Заметим свойство унимодального массива, что если $a[i] < a[j]$, то все элементы массива, левее a[i] можно не рассматривать, так как они меньше a[i]. Аналогично, если $a[i] > a[j]$, то правее a[j] тоже можно не искать максимума. (Округления в решении опущены, так как это не влияет на асимптотику)
	\\ Сделаем два счетчика, l=1,r=n. Наш инвариант - максимум находится на отрезке [l..r]. Сделаем два хода, узнаем информацию о $a[(l+r)/2]$ и $a[(l+r)/2+1]$. Если $a[(l+r)/2] < a[(l+r)/2+1]$, то приравниваем l = (l+r)/2 + 1, иначе r = (l+r)/2. Таким образом, мы будем сужать постоянно область поиска в два раза, и когда счетчики l и r сравняются, элемент a[l] и будет максимальным.
	\\ Рассмотрим формулу решения рекурсивным способом: $T(n) = T(n/2) + 2$. Константа два, потому что нам необходимо два запроса для сужения области поиска. $d = log_2(1) = 0$, $n^d = 1$, $2 = O(1)$. По основной теореме рекурсии, сложность вызовов будет O(log(n)).
	\\ Либо можно рассмотреть дерево запросов, у него высота будет h(худший случай). При этом, h = log(n). Количество вызовов будет в таком случае 2*h+c=2*log(n) + c.
	

	\prsubstar Докажите, что можно найти значение максимального элемента за не более чем $\log_a n + c$ ходов, где $a=\frac{1+\sqrt{5}}{2}$


	\Pr[2] Имеется $n$ монет, среди которых одна фальшивая, и чашечные весы.
	Настоящие монеты все имеют одинаковый вес, а фальшивая легче. На каждую чашку весов можно класть произвольное количество монет.
	Докажите, что фальшивую монету можно найти за $\log_3 n+c$ взвешиваний.
	\newline
	\\ Разобьем группу из n монет на 3 группы. Если n = 3k+1, то разобьем на группы (k,k,k+1). Если n = 3k+2, то на группы (k,k+1,k+1). 
	\\ Возьмем две группы с одинаковым количеством монет, сравним между собой. Если какая-то из них легче, значит в этой группе и находится фальшивая монета, поэтому рекурсивно начинаем искать фальшивую монету в более легкой группе. Если же две группы оказались равны, значит фальшивая монета находится в третьей, незадействованной, группе. Поэтому начинаем рекурсивно искать фальшивую монету в этой группе. Когда останется группа из 3 монет или меньше, останется сделать последнее взвешивание между двумя монетами из оставшихся. Если монет всего осталось две, то меньшая из них и будет фальшивая. Если всего осталось 3 монеты, то возможен вариант,когда две монеты равны по весу, значит фальшивая - третья. Более того, в случае, если у нас осталось 4 монеты, мы можем сравнить две из них, и если одна легче, то она и будет фальшивой.
	\\ Для поиска фальшивой монеты можно построить тернарное дерево, где путь от корня до листа и будет одним из вариантов возможных результатов взвешиваний. Листом будем считать группу из 4 или меньше монет. Найти в листе фальшивую можно за 1 или 2 взвешивания, то есть за c взвешиваний. Длина пути - $\log_3n$. Поэтому за $\log_3 n + c$ ходов можно найти фальшивую монету.

	\Pr[3] Докажите, что в условиях предыдущей задачи для нахождения фальшивой
	монеты необходимо $\log_3 n + c$ взвешиваний.
	\newline
	\\ Построим для нашего алгоритма дерево решений. Пусть мы можем делать запрос S, а в ответ нам приходит 0,1 или 2(0 - одна группа содержит фальшивую, 1 - другая, 2 третья.). У нас будет тернарное дерево, его высоту примем за h. Листьев в полном тернарном дереве будет $3^h$. Так как дерево решений у нас содержит не больше листьев, чем полное дерево высоты h, и не меньше, чем n, то должно выполняться $3^h \geq n \to h \geq \log_3n$. Величина h носит смысл количества взвешиваний, поэтому из показанного ранее, нам необходимо не менее $\log_3 n + c$ взвешиваний.

	\Pr[4] Даны два отсортированных массива длины $n$. Предложите как можно более эффективный алгоритм поиска медианы в массиве, состоящем из всех данных $2n$ элементов. Можно считать, что все элементы различные. Докажите корректность алгоритма и оцените его сложность (количество сравнений). В этой задаче обращения к элементам массива выполняются за O(1), читать оба массива целиком не требуется, считайте, что они уже лежат в памяти.
	\newline
	\\ Заведем 4 указателя, по два на массив. Они будут ограничивать области массивов, в которых идет поиск. В начале два указателя указывают на начала массивов, и другие два - на концы. Назовем их $l_1,l_2,r_1,r_2$. Сравним медианы массивов, то есть $a_1[(l_1+r_1)/2]$ и $a_2[(l_2+r_2)/2]$. 
	\\Если медиана первого массива меньше, то это значит, что все элементы меньше его будут находится в левой части массива, полученного при слиянии и сортировке исходных двух. А все элементы больше медианы второго массива будут в правой части, поэтому эти куски массивов больше можно не рассматривать. Поэтому изменяем указатели на $l_1 = (l_1+r_1)/2, r_2 = (l_2+r_2)/2$.
	\\ Если же наоборот, медиана первого массива оказалась больше, то аналогично, можно не рассматривать вторую половину первого массива и первую половину второго. Меняем указатели следующим образои: $l_2 = (l_2+r_2)/2, r_1 = (l_1+r_1)/2$.
	\\ Когда в обоих массивах остается по 2 элемента или меньше, просто высчитываем из них медианное значение, оно и будет медианой массива из 2n элементов.
	\\ Корректность: Алгоритм построен таким образом, что медиана всегда находится между указателями, а при сужении области поиска, отбрасывается равное количество элементов, заведомо левее или правее медианы объединенного массива. Отбрасывание легально, потому что массивы отсортированы. И если медиана одного массива меньше медианы другого массива, то все элементы, левее меньшей медианы, находятся левее, чем элементы правой половины своего массива и правой половины второго массива. То есть справа от них уже есть минимум n элементов, значит они меньше медианы объединенного массива, и рассмаривать их не имеет смысла. Аналогично с элементами правой половины второго массива, слева от них тоже будет n элементов в объединенном массиве.
	\\ Сложность: каждый раз при отсечении элементов область поиска сужается в два раза. То есть у нас работает рекуррентная формула $T(n) = T(n/2) + const$. Сложность алгоритма будет по этой причине $O(\log(n))$.

	\Pr[4] Определите, что число является значением данного многочлена с натуральными (целыми положительными) коэффициентами в натуральной точке. На вход задачи подаются натуральные числа $n, a_0, \ldots, a_n$ и $y$. Необходимо определить, существует ли натуральное число $x$, такое что $$ y = a_n x^n + a_{n-1} x^{n-1} + \ldots + a_1x +  a_0. $$   
В этой задаче модель с арифметическими операциями за $O(1)$.
    \newline
    \\ Заметим, что многочлен с положительными коэффициентами на множестве натуральных чисел - монотонная функция. Действительно, $\forall x>y:a_ix^i >a_iy^i$.
    \\ Также ограничим область поиска х отрезком $[1 \ldots y]$. Потому что искать x больше y не имеет смысла, так как $a_n y^n + a_{n-1} y^{n-1} + \ldots + a_1y +  a_0>y$.
    \\ Вычислить значение полинома можно за линию, благодаря тому, что арифметические операции делаются за O(1). Это делается следующей итерацией: $z_0 = a_n, z_i = z_{i-1}*x+a_{n-i}$. i пробегает от 1 до n. Всего будет n итеарций, на каждой итерации делаем 2 операции, умножение и сложение. Поэтому за 2n=O(n) операций вычисляется полином.
    \\ Также понятно, что если y меньше суммы коэффицеиентов полинома, то решения заведомо не существует. Поэтому можно сделать проверку на это в самом начале работы алгоритма.
    \\ Будем искать решение уравнения бинарным поиском: сначала возьмем значение y/2, вычислим значение полинома в этой точке. Если это значение больше, чем y, то будем искать решение на отрезке [1..y/2-1], если больше, то будем искать решение на [y/2+1..y]. Если же значение в точке равно y, значит мы нашли искомый x. Поиск идет до тех пор, пока область поиска не сузится до 1 точки. Если значение полинома в этой точке не равно y, то такого x не существует.
    \\ Корректность: полином - монотонная функция. Поэтому мы всегда сужаем область поиска таким образом, что отбрасываемые точки заведомо дают большее или меньшее значение, чем y. Алгоритм остановится, так как область поиска всегда сужается в два раза.
    \\ При каждом сужении области поиска, оно уменьшается в два раза. Мы можем построить дерево решения для этого случая, его высота будет равна $\log(y)$. Каждый раз мы считаем значения полинома за O(n). Поэтому итоговая сложность алгоритма будет $O(n\log(y))$.
	
	\prstar Ваш лектор по алгоритмам нашёл два одинаковых прочных шарика из неизвестного материала и внезапно решил измерить их прочность в этажах стоэтажного небоскрёба: прочность равна номеру минимального этажа, при броске шарика из окна которого шарик разобъётся (максимум 100). Считаем, что если шарик уцелел, то его прочность после броска не уменьшилась. Сколько бросков шариков необходимо и достаточно для нахождения прочности?
	\newline
	\\ Пусть необходимое и достаточное число бросков - N.
	\\ Допустим, мы сделали бросок с некоторой высоты h, и шарик разбился. У нас остался один шарик, и чтобы точно вычислить прочность, нам надо будет бросать его начиная с первого этажа, пошагово повышая высоту на один этаж. Чтобы точно определить прочность с помощью одного шарика для дома высоты h-1, необходимо будет сделать h-1 бросков в худшем случае. Поэтому, если мы сразу разбили первый шарик с высоты h, то нам еще надо будет сделать в худшем случае h-1 бросков вторым шариком. Всего будет сделано 1+h-1=h бросков. По нашему предположению, необходимо и достаточно - N бросков. Значит, первый бросок надо сделать с высоты N.
	\\ Теперь допустим, что мы сделали первый бросок с высоты N. У нас в запасе осталось N-1 бросков. Делаем второй бросок с высоты $h_2$, где $N < h_2 < 100$. Если шарик разбился, то вторым шариком нам надо будет сделать в худшем случае $h_2 - 1$ бросков. То есть мы сделаем $1+h_2-1$ бросков. Но у нас по предположению оставалось N-1 бросков. То есть во второй раз надо кидать шарик с высоты $N+N-1=2N-1$.
	\\ Продолжая рассуждения, получаем арифметическую прогрессию: $N+(N-1)+(N-2)+...+1=\frac{N(N+1)}{2}$. Это высота, с которой надо будет скинуть шарик в последний раз. Высота должна покрывать высоту здания, поэтому $\frac{N(N+1)}{2} \geq 100$. Решая в натуральных числах, получим N = 14.
	\\ Таким образом, если первый шарик будет достатоно прочным, чтобы не сломаться, то его надо будет бросать последовательно с высот 14,27,39,50,60,69,77,84,90,95,99,100.
	\\ Если взять меньше, например N=13, то бросков может не хватить, так как:
	\\ 13,25,36,46,54,62,69,75,80,84,87,89,90. Как видно, нам не хватило бросков, чтобы покрыть все этажи, значит мы могли не найти этаж, с которого будут разбиваться шарики.
	
	
	\prstar Необходимо узнать, есть ли в простом неориентированном графе (без петель и кратных рёбер) на вершинах $\{1,2,\ldots, n\}$ клика\footnote{Подграф на ($n-1$)-ой вершине, в котором все  вершины соединены между собой рёбрами.} размера $n-1$. За шаг алгоритм проверяет, существует ли ребро между $i$-ой и $j$-ой вершиной. Докажите, что алгоритм, решающий задачу, в худшем случае обязан проверить все рёбра. 

\end{document}
  