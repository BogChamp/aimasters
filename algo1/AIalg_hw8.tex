\documentclass[12pt]{extreport}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}        % Кодировка входного документа;
                                    % при необходимости, вместо cp1251
                                    % можно указать cp866 (Alt-кодировка
                                    % DOS) или koi8-r.

\usepackage[english,russian]{babel} % Включение русификации, русских и
                                    % английских стилей и переносов
%%\usepackage{a4}
%%\usepackage{moreverb}
\usepackage{amsmath,amsfonts,amsthm,amssymb,amsbsy,amstext,amscd,amsxtra,multicol}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning}
\usepackage{multicol} %Несколько колонок
\usepackage{graphicx}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[stable]{footmisc}

\usepackage[linesnumbered]{algorithm2e}   

%% \voffset-5mm
%% \def\baselinestretch{1.44}
\renewcommand{\theequation}{\arabic{equation}}
\def\hm#1{#1\nobreak\discretionary{}{\hbox{$#1$}}{}}
\newtheorem{Lemma}{Лемма}
\theoremstyle{definiton}
\newtheorem{Remark}{Замечание}
%%\newtheorem{Def}{Определение}
\newtheorem{Claim}{Утверждение}
\newtheorem{Cor}{Следствие}
\newtheorem{Theorem}{Теорема}
\theoremstyle{definition}
\newtheorem{Example}{Пример}
\newtheorem*{known}{Теорема}
\def\proofname{Доказательство}
\theoremstyle{definition}
\newtheorem{Def}{Определение}

%% \newenvironment{Example} % имя окружения
%% {\par\noindent{\bf Пример.}} % команды для \begin
%% {\hfill$\scriptstyle\qed$} % команды для \end






%\date{22 июня 2011 г.}
\let\leq\leqslant
\let\geq\geqslant
\def\MT{\mathrm{MT}}
%Обозначения ``ажуром''
\def\BB{\mathbb B}
\def\CC{\mathbb C}
\def\RR{\mathbb R}
\def\SS{\mathbb S}
\def\ZZ{\mathbb Z}
\def\NN{\mathbb N}
\def\FF{\mathbb F}
%греческие буквы
\let\epsilon\varepsilon
\let\es\varnothing
\let\eps\varepsilon
\let\al\alpha
\let\sg\sigma
\let\ga\gamma
\let\ph\varphi
\let\om\omega
\let\ld\lambda
\let\Ld\Lambda
\let\vk\varkappa
\let\Om\Omega
\def\abstractname{}

\def\R{{\cal R}}
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}
\def\D{{\cal D}}

%классы сложности
\def\REG{{\mathsf{REG}}}
\def\CFL{{\mathsf{CFL}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%% Enumerations %%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Rnum}[1]{\expandafter{\romannumeral #1\relax}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

%%%%%%%%%%%%%%%%%%%%% EOF Enumerations %%%%%%%%%%%%%%%%%%%%%

\usepackage{xparse}
\usepackage{ifthen}
\usepackage{bm} %%% bf in math mode
\usepackage{color}
%\usepackage[usenames,dvipsnames]{xcolor}

\definecolor{Gray555}{HTML}{555555}
\definecolor{Gray444}{HTML}{444444}
\definecolor{Gray333}{HTML}{333333}


\newcounter{problem}
\newcounter{uproblem}
\newcounter{subproblem}
\newcounter{subrproblem}
\newcounter{prvar}


\def\pr{\medskip\noindent\stepcounter{problem}{\bf \theproblem .\;}\setcounter{subproblem}{0}\setcounter{subrproblem}{0}}
\def\pru{\medskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^\circ$\!\!.\;}\setcounter{subproblem}{0}\setcounter{subrproblem}{0}}
\def\prstar{\medskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^*$\negthickspace.}\setcounter{subproblem}{0}\setcounter{subrproblem}{0}\;}
\def\prpfrom[#1]{\medskip\noindent\stepcounter{problem}{\bf Задача \theproblem~(№#1 из задания).  }\setcounter{subproblem}{0}\setcounter{subrproblem}{0} }
\def\prp{\medskip\noindent\stepcounter{problem}{\bf Задача \theproblem .  }\setcounter{subproblem}{0}\setcounter{subrproblem}{0} }

\def\prpvar{\medskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem \;$\langle${\rm\Rnum{\theprvar}}$\rangle$.}\setcounter{subproblem}{0}\setcounter{subrproblem}{0}\;}
\def\prpv{\medskip\noindent\stepcounter{prvar}{\bf Задача \theproblem \,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$.  }\setcounter{subproblem}{0}\setcounter{subrproblem}{0} }
\def\prv{\medskip\noindent\stepcounter{prvar}{\bf \theproblem\,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}.\setcounter{subproblem}{0}\setcounter{subrproblem}{0} }

\def\prpstar{\medskip\noindent\stepcounter{problem}{\bf Задача $\bf\theproblem^*$\negthickspace.  }\setcounter{subproblem}{0}\setcounter{subrproblem}{0} }
\def\prdag{\medskip\noindent\stepcounter{problem}{\bf Задача $\theproblem^{^\dagger}$\negthickspace\,.  }\setcounter{subproblem}{0}\setcounter{subrproblem}{0} }
\def\upr{\medskip\noindent\stepcounter{uproblem}{\bf Упражнение \theuproblem .}\setcounter{subproblem}{0}\setcounter{subrproblem}{0}\;}
%\def\prp{\vspace{5pt}\stepcounter{problem}{\bf Задача \theproblem .  } }
%\def\prs{\vspace{5pt}\stepcounter{problem}{\bf \theproblem .*   }
\def\prsub{\medskip\noindent\stepcounter{subproblem}\setcounter{subrproblem}{0}{\sf \thesubproblem .}\;}
\def\prsubr{\medskip\noindent\stepcounter{subrproblem}{\bf \asbuk{subrproblem})}\;}
\def\prsubstar{\medskip\noindent\stepcounter{subrproblem}{\rm $\thesubrproblem^*$\negthickspace.}\;}
\def\prsubrstar{\medskip\noindent\stepcounter{subrproblem}{$\text{\bf \asbuk{subrproblem}}^*\text{\textbf{)}}\mathbf{}$}\;}

\newcommand{\bracketspace}[1]{\phantom{(}\!\!{#1}\!\!\phantom{)}}

\DeclareDocumentCommand{\Prpvar}{ O{null} O{} }{
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem
% 	\ifthenelse{\equal{#1}{null}}{  }{ {\sf $\bm\langle$\bracketspace{#1}$\bm\rangle$}}
%	~\!\!(\bracketspace{{\rm\Rnum{\theprvar}}}).  }\setcounter{subproblem}{0}\setcounter{subrproblem}{0}
%	\;(\bracketspace{{\rm\Rnum{\theprvar}}})}\setcounter{subproblem}{0}\setcounter{subrproblem}{0}
%
	\,{\sf $\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}}.

}
%\DeclareDocumentCommand{\Prpvar}{ O{level} O{meta} m }{\prpvar}


\DeclareDocumentCommand{\Prp}{ O{null} O{null} }{\setcounter{subproblem}{0}\setcounter{subrproblem}{0}
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача \theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

\DeclareDocumentCommand{\Pr}{ O{null} O{null} }{\setcounter{subproblem}{0}\setcounter{subrproblem}{0}
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf\theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}


\DeclareDocumentCommand{\Prstar}{ O{null} O{null} }{\setcounter{subproblem}{0}\setcounter{subrproblem}{0}
		\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf$\mathbf{\theproblem^*}$
		~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
		 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

%\DeclareDocumentCommand{\Prp}{ O{level} O{meta} }

\DeclareDocumentCommand{\Prps}{ O{null} O{null} }{\setcounter{subproblem}{0}\setcounter{subrproblem}{0}
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^* $
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}

\DeclareDocumentCommand{\Prpd}{ O{null} O{null} }{\setcounter{subproblem}{0}\setcounter{subrproblem}{0}
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^\dagger$
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}


\def\prend{
	\bigskip
%	\bigskip
}


\def\prskip{
	\medskip
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EOF Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%\usepackage{erewhon}
%\usepackage{heuristica}
%\usepackage{gentium}

\usepackage[portrait, top=3cm, bottom=1.5cm, left=3cm, right=2cm]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\lhead{\fontfamily{fca}\selectfont {AI-Masters :: Алгоритмы 2022} }
%\lhead{ \bf  {ТРЯП. } Семинар 1 }
%\chead{\fontfamily{fca}\selectfont {Вариант 1}}
\rhead{\fontfamily{fca}\selectfont Домашнее задание 8}
%\rhead{\small 01.09.2016}
\cfoot{}

\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter {\setcounter{problem}{0}}  }{}{1em}{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Обозначения и операции %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
                                                                    
\newcommand{\divisible}{\mathop{\raisebox{-2pt}{\vdots}}}           
\let\Om\Omega


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Shen Macroses %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\w}[1]{{\hbox{\texttt{#1}}}}
\usepackage{wrapfig}
\def\bin{\mathrm{bin}}



\begin{document}	
	 \noindent\textbf{Преамбула.} Приведём базовые определения из теории графов, которые используются в формулировках задач, и которые нужно правильно использовать при их решении.

	\medskip

	\emph{Степенью вершины} $u$ (неориентированного графа) называют количество рёбер $\mathrm{deg}(u)$, смежных с этой вершиной. В ориентированном графе \emph{исходящей степенью} $\mathrm{deg}_{+}(u)$ вершины $u$ называют количество рёбер, исходящих из $u$ ($u$ "--- левый конец), а \emph{входящей степенью} $\mathrm{deg}_{-}(u)$ называют количество рёбер, входящих в $u$ ($u$ "--- правый конец). %Мы обозначаем степени через $\mathrm{deg}, \mathrm{deg}_{+}$ и $\mathrm{deg}_{-}$ соответсвенно.

	\emph{Путём} называется последовательность вершин $v_1, \ldots, v_n$, каждая соседняя пара вершин которой соединена ребром. Путь называется \emph{простым}, если все вершины различны. \emph{Длина пути} "--- это количество рёбер между вершинами пути, т.е. $n-1$. \emph{Цикл} "--- это путь, у которого первая и последняя вершина совпадают. \emph{Простой цикл} "--- это цикл, все вершины которого различны (за исключением первой и последней).

	%\medskip

	Ориентированный граф называют \emph{турниром}, если между каждой парой его вершин есть ровно одно ребро. Также такие графы называют \emph{полными} ориентированными графами. %\noindent\textbf{Определение.} 

	\emph{DAG} "--- это ориентированный ациклический граф (Directed Acyclic Graph).

	Неориентированный граф называется \emph{двудольным}, если множество его вершин разбивается на два множества $V = L \cup R,\, L\cap R = \es$, таких что один конец каждого ребра лежит в $L$, а другой в $R$. Эти множества называются левой и правой долями соответственно. \emph{Паросочетание} в двудольном графе "--- такое подмножество рёбер $E^{\prime}$, что правые и левые концы любых двух рёбер из этого множества попарно различны.  То есть, если $(u,v), (a,b) \in E^{\prime}$ и $u,a \in L$ и $ v, b \in R$, то $u\neq a$, а $v \neq b$.


	\prend

\Pr[2] На вход задачи подаётся граф $G$ и его верины $s$ и $t$. Постройте алгоритм, который за время $O(|V| + |E|)$ проверяет, что вершина~$t$ достижима из вершины~$s$. Решите задачу как в случае, когда $G$ неориентированный граф, так и в случае, когда $G$ ориентированный граф.
\newline
\\Для решения задачи будем использовать обход в глубину. Сделаем хэш-таблицу, ключами которой будут вершины графа, а значениями - нули и единицы. Ноль - если вершина еще не была посещена, единица - если была. Запускаем обход в глубину из вершины s, заходя только в те вершины, которые не были посещены. При посещении очередной вершины делаем следующие действия: в хэш-таблице ставим единицу этой вершине, проверяем, является ли данная вершина искомой, и если да - то выдаем ответ, что путь есть, иначе запускаем рекурсивно обход по всем вершинам, которые смежны с текущей вершиной и не были посещены. По итогу алгоритм будет завершен либо когда пройдет по всем достижимым вершинам из s, либо когда алгоритм найдет вершину t.
\\Корректность - при обходе в глубину мы проходим все вершины, которые достижимы из начальной вершины, так как алгоритм не останавливается, пока не найдена нужная вершина или пока есть вершины, в которые есть ребра и которые не были посещены. Мы начинаем из вершины s, соответственно все вершины, которые посещаются в течение алгоритма, достижимы из s. И если есть путь из s в t, то путь будет найден, так как изначально t не посещена, и если мы в нее не попали, значит алгоритм не перешел в непосещенную вершину, что противоречит построенному алгоритму. Очевидно, что алгоритм работает как и для ориентированного, так и неориентированного графа, так как в случае ориентированного графа можно будет идти только по исходящим ребрам.
\\ Сложность алгоритма - $O(|V| + |E|)$, так как при обходе в глубину мы по каждому ребру и каждой вершине проходимся дважды - когда мы впервые по ним проходим, и когда возвращаемся из рекурсии.

\prend

% Разбирается в классе %\Pr[3] В графе $G$ был проведён поиск в глубину. Время открытия и закрытия вершин сохранено в массивах $d$ и $f$. Постройте алгоритм, который используя только данные из массивов~$d$ и $f$ (и описание графа) проверяет, является ли ребро $e$ графа $G$ \prsubr прямым ребром; \prsubr перекрёстным ребром. 
	
%	\noindent\textsl{См. определения в Кормене (глава про поиск в глубину).  } 
	
	\medskip
	
	\Pr[2] Вам нужно выбраться из лабиринта. Вы не знаете, сколько в нем комнат, и какая у него карта. По всем коридорам можно свободно перемещаться в обе стороны, все комнаты и коридоры выглядят одинаково (комнаты могут отличаться только количеством коридоров). Пусть $m$ - количество коридоров между комнатами. Предложите алгоритм, который находит выход из лабиринта (или доказывает, что его нет) за $O(m)$ переходов между комнатами. В вашем расположении имеется неограниченное количество монет, которые вы можете оставлять в комнатах, причем вы знаете, что кроме ваших монет, никаких других в лабиринте нет, и вы находитесь в нем одни.
	\newline
	\\Если формализовать задачу, то можно ее описать как: у нас есть неориентированный граф без цикл и петель, нам нужно выяснить, есть ли путь из одной данной вершины(в которой мы находимся в данной момент), назовем ее s, в другую(выход из лабиринта), назовем ее t. По сути задача сводится к предыдущей. Алгоритм будет такой же, будем обходить граф(комнаты) в глубину. При посещении очередной вершины(комнаты) мы будем оставлять одну монету в ней, таким образом маркируя, что мы тут были. Очевидно, посещать будем те вершины, которые еще не посещали. Если будет такая ситуация, что все смежные комнаты уже были посещены, а выхода из лабиринта в комнате нет, то  кладем в данной комнате две монеты, что будет означать, что в данной вершине мы не нашли путь до выхода. После этого, возвращаемся в ту комнату, из которой пришли, смотрим, есть ли непосещенные комнаты по соседству, и если нет, то кладем вторую монету в комнате, далее возвращаемся в предыдущую комнату и так далее. Таким образом мы симулируем обход графа в глубину. Две монеты в комнате означает, что сюда мы больше не заходим, выход не был найден из этой вершины. Одна монета означает, что мы посетили эту комнату при поиске в глубину, и потенциально можем найти путь к выходу, проходящую через эту вершину, то есть пока не вернулись обратно в эту комнату. Комната без монет означает, что мы ее не посещали.
	\\Корректность следует из решения предыдущей задачи.
	\\Сложность. Будем считать, что в нашем случае граф связен, то есть из любой комнаты можно попасть в другую. В противном случае, наш алгоритм даже не попадет в вершины, которые не достижимы из нашего начального положения, поэтому мы их можем отбросить. В связном графе из n вершин как минимум n-1 ребер. Таким образом, можно ограничить количество вершин сверху $n \leq m+1$, где m - количество ребер. Так как сложность обхода в глубину $O(n+m)$, то $O(n+m)=O(m+1+m)=O(m)$.
	
	

	\Pr[3] Докажите, что каждый турнир на $n$ вершинах содержит простой путь длины $n-1$. Постройте алгоритм, который получив на вход турнир, находит в нём такой путь, и оцените асимптотику его времени работы.
	\newline
	\\Докажем это индуктивно. Рассмотрим случай n=3. У нас могут быть две ситуации - либо когда в кажду вершину входит не более одного ребра(имеется ввиду, что входящее ребро лишь одно), либо есть вершина, в которую входят два ребра. В первом случае, у каждой вершины есть одно входящее и исходящее ребро, поэтому есть путь, началом которого может быть любая вершина, а конец -  вершина, из которой есть исходящее ребро в начальную вершину. Длина пути будет 2. Во втором, среди оставшихся двух вершин есть ребро, которое исходит из одной вершины в другую. Вершину, из которой исходит это ребро, возьмем первой, средней - ту вершину, в которую входит это ребро, а последней в пути будет та вершина, в которую входят два ребра. Длина пути снова будет 2.
	\\ Пусть теперь утверждение верно для $n$ вершин. Проверим утверждение для n+1 вершин. Возьмем подграф из $n$ вершин из турнира из $n+1$ вершин. В данном подграфе есть путь длиной $n-1$, пусть начало это вершина $v_1$, а конец - $v_n$. Рассмотрим оставшуюся вершину $u$.В графе есть ребро $u \to v_1$ или $v_1 \to u$. Если есть ребро $u \to v_1$, то искомый путь  - $u,v_1,\ldots,v_n$ - длина n. Иначе рассмотрим вершины $v_i$, которые присутствуют в пути длиной n. Либо среди них есть какая-то вершина $v_k$, такая что она первая в последовательности вершин с ребром $u \to v_k$, либо у вершины u нет исходящих ребер. В первом случае есть ребро $v_{k-1} \to u$, так как до $v_k$ нет вершин, в которые исходит ребро из u, и таким образом существует путь $v_1\ldots v_{k-1}uv_k\ldots v_n$. Во втором случае есть путь $v_1 \ldots v_nu$. Оба пути длиной n. Таким образом, утверждение доказано.

	\prend

	\Pr[1+6] В государстве между $n$ городами есть $m$ одностронних дорог. Было решено разделить города государства на наименьшее количество областей так, чтобы внутри каждой области все города были достижимы друг из друга.
	\prsub Предложите эффективный алгоритм, который осуществляет такое разделение, докажите его корректность и оцените асимптотику.
	\newline
	\\ По сути, у нас есть граф, где дороги - ребра, города - вершины. Чтобы создать наименьшее количество областей, нужно найти КСС нашего графа.
	\\ Алогритм поиска КСС - такой же, который предложен на лекции. Сделаем обход в глубину в нашем графе, будем записывать время открытия и закрытия каждой вершины. Затем в исходном графе развернем все ребра, и сделаем в нем обход в глубину в порядке, обратном их порядку закрытия. Как только начинаем обход, добавляем все вершины, достижимые из текущей, в однй компоненту связности. Таким образом, объединим все вершины в группы КСС.
	\\Корректность. Понятно, что каждая вершина лежит в одной КСС только с теми вершинами, которые достижимы из нее. И так как вершины в одной КСС лежат на цикле, разворачивание ребер не сломает эти циклы. Когда мы делаем второй обход, мы рассматриваем вершины в порядке топологической сортировки. Поэтому мы сначала находим КСС, в которой лежит первая вершина, затем следующую непосещенную и так далее.
	\\Сложнось - мы два раза обходим граф в глубину, поэтому сложность $O(n+m)$.
	
	\prsubstar Государство решило добиться того, чтобы из каждого города можно было добраться до каждого. В силу бюджетных ограничений, было решено  построить минимальное число односторонних дорог (не важно какой длины), необходимое для достижения этой цели. Предложите алгоритм, решающий задачу.
	\newline
	\\ Чтобы можно было из каждого города перебраться в каждый, достаточно, чтобы из каждой КСС можно было перебраться в каждую. То есть, рассмотрим каждую КСС как отдельную вершину. Чтобы вновь полученный граф был сильно связен, необходимо и достаточно, чтобы степень входа и исхода каждой вершины была минимум 1. Таким образом, подсчитав количество исходящих ребер в графе и входящих, то минимальное количество ребер(дорог), которое надо построить, будет $max(n-deg|E|_+, n-deg|E|_-)$. Чтобы найти эти самые ребра, рассмотрим КСС в порядке топологической сортировки(по сути, объединив вершины в КСС, мы получили DAG). Единственное условие, В процесс прохода по КСС если натыкаемся на КСС, у которой нет исходящего ребра в следующуу КСС, просто добавляем ребро, которое исходит из этой КСС и входит в следующее по порядку. Как только мы доходим до конца массива из КСС, то нам остается объединить последнюю КСС с первой.
	\\Корректность. В топологической сортировке ребра идут только вперед. Пройдя по массиву КСС, полученном из топологической сортировке и добавляя ребра, мы как раз уменьшаем количество стоков и истоков на один. Очеивдно, алогритм добавит как раз $max(n-deg|E|_+, n-deg|E|_-)$ ребер.
	\\Сложность - мы использовали обход в глубину пару раз и проход по массиву КСС. Таким образом, сложность $O(n+m)$.



	\Pr[3]  Дан орграф на $n$ вершинах ($V = \{1,\ldots, n\}$), который получен из графа-пути (рёбра, которого ведут из вершины $i$ в $i+1$) добавлением ещё каких-то~$m$ данных ребер. Найдите количество сильно связных компонент за $O(m\log m)$.
	\newline
	\\У нас есть массив из m ребер, то есть из m пар вершин, которые задают ребра. Отсортируем данный массив по второму концу, то есть по вершинам, в которые ведут ориентированные ребра. Порядок на вершинах будем использовать следующий: $v_1 < v_2 < \ldots v_n$. При сортировке также будем выполнять следующие действия: если у ребра $(x,y)$ выполняется $x < y$, то мы его отбрасываем и больше не рассматриваем вовсе, так как такое ребро не добавляет вершин связности, так как в графе уже был путь из $x$ в $y$. Под отбрасыванием имеется ввиду либо удаление ребра из массива, либо просто игнорирование их при последуюшей работе алгоритма. Компоненты связности добавляют лишь те ребра, которые создают циклы. После сортировки будем иметь массив ребер, чьи концы отсортированы по убыванию и которые точно образуют компоненты связности в исходном графе.
	\\ Делаем проход по отсортированному массиву. Как было сказано выше, если у нас есть ребра такие, что в исходном графе его начало раньше конца, мы просто проходим такие ребра и ничего не делаем с ними. Пусть у нас есть переменная $res$, которая хранит количество компонент сильной связности, которые найдены на данный момент.
	\\ Пусть в текущий момент мы на ребре $(i, j)$. У нас такое ребро задает компоненту связности. Идем по массиву до тех пор, пока не наткнемся до ребра $(n,m)$ такого что $n > m$, то есть игнорируя ребра, описанные выше. У нас возможно два случая. Первый случай - $j<m<i<n$ или $j<m<n<i$.В таком случае, два ребра входят в одну компоненту связности, мы ничего не делаем, обходим массив дальше.
	\\Второй случай: $j<i<m<n$. То есть два ребра не пересекаются, и относятся к разным компонентам связности. В таком случае увеличиваем $res$ на единицу и продолжаем обход массива.
	\\Алгоритм будет работать до тех пор, пока не достигнет посленего элемента массива. При достижении конца, тоже увеличиваем $res$ на 1.
	\\Корректность: компоненту связности добавляет только те ребра, которые направлены в другом направлении, чем ребра в исходном графе(до добавления m ребер). Поэтому надо рассмотреть только такие ребра, что и делает алгоритм. Если два ребра пересекаются(конец одного находится между началом и концом другого) или одно ребро поглощает другое(начало и конец одного ребра между началом и концом другого), то они принадлежат к одной компоненте связности, так как из конца одного ребра всегда можно попасть в начало другого ребра(потому что исходный граф-путь), а из начал ребер можно вернуться в предыдущие вершины. Если два ребра не пересекаются, то между началом одного ребра и концом другого есть хотя бы одна вершина, из которой нельзя попасть в предыдущие вершины, потому что ребра в исхдном графе идут в одном направлении. Поэтому такие ребра в разных сильно связных компонентах.
	\\Сложность: Сначала мы отсортировываем массив длины m, например merge-сортом за $O(m\log(m))$, затем делаем один проход по нему за $O(m)$. Поэтому итоговая сложность будет $O(m \log(m))$.

	%Дан ориентированный граф на $n$ вершин, первые $n-m$ вершин которого образуют путь (рёбра идут из $i$ в $i+1$) на и ещё $m$ каких-то данных ребер. Найдите количество сильно свзяных компонент за $O(mlog m)$ 


	\Pr[3] На вход задачи поступает описание двудольного графа $G(L,R,E)$, степень каждой вершины которого равна двум. Необходимо найти максимальное паросочетание в $G$ (которое содержит максимальное количество рёбер). Предложите алгоритм, решающий задачу за $O(|V| +|E|)$.
	\newline
	\\ Степень каждой вершины равна двум. Также мы знаем, что если мы просуммируем все степени вершин графа, то мы получим удвоенное количество ребер в графе. В нашем случае получается $2*|V|=2*|E|\to |V|=|E|$. Количество ребер равно количеству вершин. Более того, рассмотрим доли L и R этого графа. Количество ребер, инцидентных левой части будет $2*|L|$, а справа $2*|R|$. Понятное дело, что количетво ребер инцидентных справа и слева должно быть одинаковым, так как граф двудольный, и каждое ребро имеет концы в разных частях. Таким образом мы делаем вывод, что количество вершин в правой и левой части одинаково.
	\\Если мы выберем какое-то ребро для включения его в паросочетание, то его концы, то есть вершины, не могут быть больше инцидентыми другим ребрам в паросочетании, поэтому они больше не учитываются при поиске других ребер. Таким образом, после выбора одного ребра, у нас остается $|V|-2$ вершин. Поэтому всего в максимальном паросочетании будет $|V|/2$ ребер, то есть половина от всех ребер.
	\\Собственно, сам алгоритм. Берем случайную вершину, у нее есть два ребра. Переходим по любому из них. Кладем ребро, которое мы прошли, в множество pairs, которое будет хранить паросочетание. В текущий момент мы побывали уже в двух вершинах, выкидываем их из пула рассматриваемых вершин, то есть не будем класть инцидентные им ребра в pairs. Так как нам нужно продолжить алгоритм, переходим из текущей вершины по ребру, которое мы еще не проходили, и попадаем в новую вершину. Затем, переходим по ребру, которое мы не проходили, кладем его в pairs, переходим снова по ребру, которое не посещали, не кладем его никуда, так как вершину, инцидентную с ней мы уже посещали, и так далее. Таким образом, мы проходим по ребрам таким образом, что проходим только по тем, которые еще не проходили, и кладем в pairs каждое второе пройденное ребро. Может случиться ситуация, когда мы прошли по ребру и пришли в вершину, которую уже посещали. Это значит, что мы прошли по циклу в графе. В таком случае просто начинаем обход графа из новой вершины, которою еще не посещали. Алгоритм оканчивает работу, когда он прошел все ребра.
	\\Корректность. Докажем, что в максимальном паросочетании не может быть $|E|/2 + 1$ ребра. Предположим, что все таки такое возможно. $|E|/2$ ребра инцинденты в сумме $2*|E|/2=|E|=|V|$ вершинам, которые попарно различны. У нас есть еще одно ребро, которое инциденто двум каким-то вершинам. Но тогда эти две вершины уже содержатся в тех $|V|$ вершинах, которые покрываются $|E|/2$ ребрами, потому что граф содержит всего $|V|$ вершин. Таким образом, максимальное паросочетание может содержать не больше $|E|/2$ ребер. Наш алгоритм как раз находит $|E|/2$ ребер, так как он проходит по всем ребрам и кладет каждое второе в паросочетание. Это дает корректный результат, так как если рассмотреть последовательность ребер, которые мы проходим, то понятно что в ней четное количество ребер(так как всего ребер четное количество, а если мы нашли цикл в графе, то он имеет четную длину по свойству двудольного графа). Любые два несмежных ребра инидентны разным вершинам. Поэтому, взяв каждое второе ребро, мы не нарушим условие паросочетания.
	\\Сложность: алгоритм по сути реализует обход графа в глубину, поэтому сложность $O(|V|+|E|)$.
	
	\Pr[3] Постройте алгоритм, который находит самый длинный путь в DAG.
	\newline
	\\ Заведем два массива - первый массив булевый, содержит столько же элементов, сколько и вершин в графе. В нем будем помечать, была ли посещена вершина или нет. Второй массив, такой же длины, который будет хранить пути максимальной длины из каждой вершины. Назовем первый массив was, и заполним его значениями False, а второй назовем path, заполним его нулями. Также заведем переменную max, который будет хранить путь максимальной длины, найденный на данный момент.
	\\ У нас есть массив вершин(как-то мы же храним информацию о том, какие вершины есть). Начнем в цикле по всем вершинам обход графа в глубину из каждой вершины. Естественно, начинаем обход только если вершина не была посещена ранее. Помечаем, что в текущей вершине мы уже были. Запустим обход в глубину рекурсивно для каждой дочерней вершины. Если какая-то дочерняя вершина уже была посещена, то обход в глубину из нее не совершается, так как мы уже знаем путь большей длины из этой вершины. Таким образом найдем самые длинные пути, доступные из каждой дочерней вершины. Затем, берем среди них самый длинный путь, прибавляем спереди к нему текущую вершину, и записываем его в соответствующее текущей вершине место в массив path. Если также длина полученного пути больше чем длина max, то записываем его в max. По окончании алгоритма, выдаем в качестве ответа max.
	\\ Корректность. Во-первых, граф ациклический, поэтому если мы начнем обход графа в глубину из какой-то вершины, то не будет такой ситуации, что мы перейдем в некоторую вершину, которая является предком изначальной вершины, иначе был бы цикл. Во-вторых, если среди дочерних вершин длина максимального пути равна n, то из текущей вершины максимальный путь равен n+1, так как можем добавить к пути ребро из текущей вершины в дочернюю. И это будет максимальным путем, доступным из текущей вершины, так как двигаться из текущей вершины мы можем только в дочерние. Поэтому максимальный путь из текущей вершины равен: текущая вершина + самый длинный путь доступный из дочерних вершин.
	\\Сложность. Каждый раз, когда мы получаем информацию о самом длинном пути из дочерних вершин, мы за $O(1)$ добавляем к этому пути текущую вершину(по сути вставляем новый элемент в начало списка). Так как мы обходим граф в глубину, то сложность данного алгоритма $O(|V|+|E|)$.
			
			
\end{document}	
  